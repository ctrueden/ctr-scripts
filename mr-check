#!/usr/bin/perl

# mr-check - Hacky script to check .mrconfig entries against git remotes.

use strict;

# Change this folder to the subdirectory where you keep your source code.
my $codeFolder = 'code';

my $home = $ENV{'HOME'};
open MRCONFIG, "$home/.mrconfig" or die $!;
my @lines = <MRCONFIG>;
close MRCONFIG;

# harvest list of git repositories from mr config file
my %repos = ();
my $dir = '';
for my $line (@lines) {
	chop $line;
	if ($line =~ /^\[(.*)\]$/) {
		$dir = $1;
	}
	if ($line =~ /^checkout\s*=\s*git\s+clone\s+(-b\s+[^\s]+\s+)?([^\s]*)/) {
		$repos{$dir} = $2;
	}
}

# compare each git repo from mrconfig with the clone's actual origin remote
my $errors = 0;
for my $dir (keys %repos) {
	my $repo = $repos{$dir};
	if (not -d "$home/$dir") {
		# skip uninitialized directory
		next;
	}
	if (not -d "$home/$dir/.git") {
		print "$dir: not a Git repository as expected!\n";
		next;
	}
	my $remote = `cd $home/$dir && git remote -v | grep '^origin.*(fetch)\$'`;
	chop $remote;
	$remote =~ s/^origin\s+(.*)\s+\(fetch\)$/$1/;
	if ($repo ne $remote) {
		print "$dir: '$repo' != '$remote'\n";
		$errors++;
	}
}

# check actual repositories beneath code folder against .mrconfig entries
my @actualRepos =
	`find "$home/$codeFolder" -name '.git' -type d -depth 3 -maxdepth 3`;
for my $actualRepo (@actualRepos) {
	chop $actualRepo;
	$actualRepo =~ s/^$home\/(.*)\/\.git$/\1/;
	if (not defined $repos{$actualRepo}) {
		print "[WARNING] $actualRepo: not in .mrconfig\n";
	}
}

exit $errors;
